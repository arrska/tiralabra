//symboli->merkki
//taajuus->todennäköisyys?

Datan pakkaaminen Huffmanin koodauksella

Huffman-koodaus on tiedon pakkaamiseen käytettävä algoritmi. Algoritmin idea on kartoittaa aakkoston eri eymbolien esiintymistaajuudet ja koodata jokainen symboli mahdollisimman lyhyellä bittijonolla siten, että eniten käytetty symboli saa lyhyimmän bitti-ilmauksen ja vähiten käytetty pisimmän.

Algoritmin yksityiskohdat
Pakkauksen ensimmäinen askel on pakattavan datan aakkoston symbolien esiintymistaajuuksien selvittäminen. Tämä vaatii symbolien esiintymien laskemisen datasta, siis koko pakattavan datan läpikäynnin. Tämän jälkeen rakennetaan Huffman-puu. Käsitellään aluksi jokaista symbolia puun lehtenä, jonka arvona on sen esiintymistiheys. Valitaan ensin kaksi harvinaisinta symbolia, eli pienimmät arvot omaavaa lehteä, ja tehdään niille emosolmu, jonka arvoksi tulee lastensa arvojen summa. Luotua solmua kohdellaan samoin kuin alkuperäisiä solmuja. Lapsiksi alennetut solmut eivät enää ole käsittelyssämme. Jatkamme samaa poimien aina kaksi pienimmät arvot omaavaa solmua ja luomalla niille emon, kunnes jäljellä on vain yksi solmu, jonka arvo on kaikkien symbolien esiintymistiheyksien summa eli 1. Tuloksena on puu, jonka lehtisolmuina ovat kaikki aakkoston symbolit.

Symbolien koodaus on on bittijono, joka saadaan kulkemalla juuresta solmuun. Kuljettaessa aina oikealle lisätään bittisekvenssiin 1 ja vasemmalle 0. Tällöin solmuun päästessä ollaan saatu bittijono, joka kertoo symbolin bittiesityksen pakatussa datassa. Itse pakkaaminen tehdään käymällä data läpi symboli kerrallaan ja kirjoittamalla aina symbolia vastaava

Näin pakatun datan purkaminen käy rekonstruoimalla puu ja lukemalla pakattua dataa bitti kerrallaan. Lähtemällä liikkeelle juuresta ja valitsemalla aina luetun bitin mukainen siirtymä, eli 1-bitillä oikea ja 0-bitillä vasen, löydetään lehti, jossa on etsimämme symboli. Lehteen päästäessä tulostetaan löydetty symboli, siirrytään takaisin juurisolmuun ja jatketaan datan lukemista.


Tehokkuus
Koodauksen voi jakaa helposti vaiheisiin
1. Lue datan aakkosto ja laske symbolien taajuudet
2. Rakenna Huffman-puu
3. Etsi kunkin symbolin bittiesitys puusta
4. Pakkaa data

n = tiedoston koko
k = aakkoston koko


Ensimmäisen kohdan aikavaativuus on O(n), koska koko data käydään kertaalleen läpi ja jokaisen luetun symbolin kohdalla kasvatetaan sen laskuria yhdellä. Oletuksena, että merkistö on ennalta tiedossa (esim. aakkoset tai tavut) ja tietorakenne, jossa lukumäärät muistataan on valmiiksi rakennettu ja sen alkioiden arvojen muuttaminen tapahtuu vakioajassa. Käytännössä toteutus voi olla yksinkertainen taulukko, jossa on jokaiselle merkille alkio, jonka arvo on 0. Taulukon alustamiseen menee aakkoston koon verran aikaa. Vaiheen tilavaativuus on O(k) olettaen, että datasta on muistissa kerrallaan vain yksi merkki.

Pseudokoodiesitys:

lukumäärät = []

while tiedostoa jäljellä
	m = lue merkki
	lukumäärät[m]++


Toinen kohta voidaan jakaa vaiheisiin
a. Järjestä solmut
b. Poimi kaksi pienintä solmua
c. Luo uusi emosolmu
d. Palaa vaiheeseen a, jos solmuja jäljellä

ja esittää pseudokoodina näin:

while solmut.lukumäärä > 1
	solmut.järjestä()
	oikea=solmut.poistapienin()
	vasen=solmut.poistapienin()
	emo=uusisolmu(oikea+vasen)
	emo.vasenlapi=vasen
	emo.oikealapsi=oikea
	solmut.lisää(emo)
	
Silmukka suoritetaan kunnes solmuja on jäljellä yksi. Koska jokaisessa suorituksessa solmuista poistetaan kaksi ja lisätään yksi, suoritetaan silmukka kerran solmua kohden, eli merkkien lukumäärän verran. Tästä nähdään myös, että syntyvässä puussa on noin tuplasti solmuja alkuperäiseen puuhun, eli akkostoon, verrattuna. Koska silmukka suoritetaan vain k-1 kertaa, lopullinen solmujen lukumäärä on k+k-1=2k-1. Tämä johtuu siitä, että <i>solmut</i>-joukosta poistettavat solmut ovat kuitenkin muodostuvan puun solmuja.
Silmukan sisällä tapahtuvat operaatiot järjestä, poistapienin ja lisää. Nämä kaikki toimivat ajassa O(log k) jos solmut säilytetään minimikeossa. Keon järjestäminen tarvitsee tehdä vain kerran ennen silmukkaan astumista, koska keko-operaatiot poistapienin ja lisää pitävät keon järjestyksessä suorittamalla korjaavat toimenpiteet ajassa O(log k). Täytyy muistaa, että näiden operaatioiden aikavaativuus on verrannollinen aakkoston (k), ei pakattavan datan kokoon (n). Aakkoston koko on usein huomattavasti pienempi, muussa tapaukssa pakkaaminen ei edes ole hyödyllistä.
Käsiteltävä puu voi kuitenkin olla pahasti epätasapainossa. Puun rakennusvaiheessa korkeus kasvaa aina kun toinen kahdesta solmusta kuuluu jo puuhun. Tällaisessa tapauksessa puun korkeus kasvaa yhdellä. Jokaisella silmukan suorituskerralla voi käydä näin, jos yhteenlaskettava arvo on aina pienempi kuin seuraavaksi pienin arvo. Tällöin jokaisen solmun arvo on aina kaksinkertainen edeltävän solmun arvoon verrattuna. Esimerkiksi arvo(alaindeksi)i=2(potenssiin)i. Täten tällaisessa pahimmassa tapauksessa puun korkeudeksi tulee k-1.
Tilaa algoritmi vie eniten silmukan viimeisellä suorituskerralla, jolloin uusia solmuja on luotu k-1 kappaletta. Tilavaativuutena siis O(k).

Kolmannessa vaiheessa kuljetaan kaikki reitit juuresta lehtiin läpi löytääksemme koodaukset. Tämä on toteutettavissa yksinkertaisesti pinoa ja syvyyssuuntaista hakua käyttämällä.

Pseudokoodiesitys bittijonot selvittävälle läpikäynnille:

pino.push(huffpuu.juuri)

while not empty pino
	solmu = pino.pop()
	if solmu on lehti
		koodit[solmu.merkki]=solmu.koodaus
		continue //takaisin silmukan suorituksen alkuun
	
	if solmu has left child
		vasen=solmu.vasen
		vasen.koodaus=solmu.koodaus+0
		pino.push(vasen)
	
	if solmu has right child
		oikea=solmu.oikea
		oikea.koodaus=solmu.koodaus+0
		pino.push(oikea)
		
Pinon push- ja pop-operaatiot toimivat vakioajassa. Pinoon laitetaan aina kertaalleen jokainen solmu, joten silmukka suoritetaan niin monta kertaa kuin solmuja on. Kuten aiemmin todettiin, solmuja on 2k-1 kappaletta. Aikavaativuus siis on O(k). Aiemmin todettiin myös, että puun maksimikorkeus on k-1. Syvyyssuuntaisen läpikäynnin tilavaativuus riippuu pinossa kerrallaan olevien solmujen määrästä. Korkeimmalla paikalla olevaa lehteä tarkasteltaessa on siis kaikki polulla olevat solmut pinossa. Tilavaativuuskin on siis O(k).

Neljäs vaihe, datan pakkaus, voidaan esittää pseudokoodina:

while tiedostoa jäljellä
	m = lue merkki
	pakattudata+=koodit[m]
	
Tämän vaiheen silmukka suoritetaan n-kertaa ja kaikki silmikassa suoritettavat operaatiot ovat vakioaikaisia. Pakkausvaiheen aikavaativuus on siis O(n).

Lähteet:
http://fi.wikipedia.org/wiki/Huffmanin_koodaus
http://en.wikipedia.org/wiki/Huffman_coding